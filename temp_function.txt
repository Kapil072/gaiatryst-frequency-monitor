  Future<void> _loadFrequencyData() async {
    try {
      // Try direct web scraping first (works for all platforms - iOS, Android, Windows)
      try {
        debugPrint('Attempting to fetch data directly from HeartMath...');
        
        // Fetch the HeartMath page
        final response = await http.get(
          Uri.parse('https://nocc.heartmath.org/power_levels/public/charts/power_levels.html'),
        ).timeout(const Duration(seconds: 15));
        
        if (response.statusCode == 200) {
          final htmlContent = response.body;
          
          // Look for the rawData variable in the JavaScript
          final RegExp regexp = RegExp(r'rawData\s*=\s*(\[.*?\]);', multiLine: true, dotAll: true);
          final Match? match = regexp.firstMatch(htmlContent);
          
          if (match != null) {
            String jsonData = match.group(1)!;
            
            // Clean the JavaScript-style data to make it valid JSON
            jsonData = jsonData.replaceAll(RegExp(r'/\*.*?\*/'), ''); // Remove comments
            jsonData = jsonData.replaceAll(RegExp(r'//.*'), ''); // Remove line comments
            jsonData = jsonData.replaceAll(RegExp(r'\b([a-zA-Z_][a-zA-Z0-9_]*)\s*:', multiLine: true), '"\$1":'); // Quote unquoted keys
            jsonData = jsonData.replaceAll(RegExp(r',\s*}'), '}'); // Remove trailing commas
            jsonData = jsonData.replaceAll(RegExp(r',\s*\]'), ']');
            
            final List<dynamic> rawData = json.decode(jsonData);
            
            // Process the data
            final Map<String, double> newCountryFreqs = {};
            double totalValue = 0;
            int activeCount = 0;
            
            for (final series in rawData) {
              final Map<String, dynamic> seriesMap = series as Map<String, dynamic>;
              final String name = seriesMap['name'].toString().toLowerCase().trim();
              final List<dynamic> dataPointsRaw = List.from(seriesMap['data'] ?? []);
              
              if (dataPointsRaw.isNotEmpty) {
                // Convert the nested lists properly
                final List<List<num>> dataPoints = [];
                for (final point in dataPointsRaw) {
                  if (point is List) {
                    dataPoints.add(List<num>.from(point));
                  }
                }
                
                if (dataPoints.isNotEmpty) {
                  final double lastValue = dataPoints.last.last.toDouble();
                  
                  // Map the names to our station IDs
                  String? stationId;
                  if (name.contains('california') || name.contains('usa')) {
                    stationId = 'GCI001';
                  } else if (name.contains('hofuf') || name.contains('saudi')) {
                    stationId = 'GCI002';
                  } else if (name.contains('lithuania')) {
                    stationId = 'GCI003';
                  } else if (name.contains('canada')) {
                    stationId = 'GCI004';
                  } else if (name.contains('new zealand')) {
                    stationId = 'GCI005';
                  } else if (name.contains('south africa')) {
                    stationId = 'GCI006';
                  }
                  
                  if (stationId != null && lastValue > 0) {
                    newCountryFreqs[stationId] = lastValue;
                    totalValue += lastValue;
                    activeCount++;
                  }
                }
              }
            }
            
            if (newCountryFreqs.isNotEmpty) {
              final double globalAvg = activeCount > 0 ? totalValue / activeCount : 0.0;
              
              setState(() {
                _averageFrequency = globalAvg;
                _countryFrequencies = newCountryFreqs;
              });
              
              debugPrint('✅ Successfully loaded live data: ${globalAvg.toStringAsFixed(2)} Hz from ${newCountryFreqs.length} stations');
              return;
            }
          }
        }
      } catch (webError) {
        debugPrint('⚠️ Web scraping failed, trying API fallback: $webError');
      }
      
      // Fallback to API
      try {
        final response = await http.get(
          Uri.parse('http://localhost:5002/api/data')
        ).timeout(const Duration(seconds: 5));
        
        if (response.statusCode == 200) {
          final data = json.decode(response.body);
          final newAvg = (data['global_avg'] as num).toDouble();
          final stationsMap = data['stations'] as Map<String, dynamic>;
          
          final Map<String, double> newCountryFreqs = {};
          for (final station in _countryNames.keys) {
            final value = stationsMap[station];
            if (value != null) {
              final freq = (value is num) ? value.toDouble() : double.tryParse(value.toString());
              if (freq != null && freq > 0) {
                newCountryFreqs[station] = freq;
              }
            }
          }
          
          setState(() {
            _averageFrequency = newAvg;
            _countryFrequencies = newCountryFreqs;
          });
          debugPrint('✅ Data loaded from API: $newAvg Hz');
          return;
        }
      } catch (apiError) {
        debugPrint('⚠️ API not available, falling back to CSV: $apiError');
      }

      // Final fallback to CSV
      final possiblePaths = [
        'gci_hourly_log_clean.csv',
        'python/gci_hourly_log_clean.csv',
        '../gci_hourly_log_clean.csv',
        '${Directory.current.path}/gci_hourly_log_clean.csv',
        '${Directory.current.path}/python/gci_hourly_log_clean.csv',
      ];

      File? csvFile;
      for (final path in possiblePaths) {
        final file = File(path);
        if (await file.exists()) {
          csvFile = file;
          break;
        }
      }

      if (csvFile == null) return;

      final csvContent = await csvFile.readAsString();
      final rows = const CsvToListConverter().convert(csvContent);

      if (rows.length < 2) return;

      final headerRow = rows[0].map((e) => e.toString().trim()).toList();
      final avgPowerIndex = headerRow.indexOf('Global Avg Power');

      if (avgPowerIndex == -1) return;

      // Find the last non-empty row that has data
      var lastRowIndex = rows.length - 1;
      while (lastRowIndex >= 1) {
        final row = rows[lastRowIndex];
        if (row.isNotEmpty && row.any((cell) => cell != null && cell.toString().trim().isNotEmpty)) {
          break;
        }
        lastRowIndex--;
      }
      
      if (lastRowIndex < 1) return;
      final lastRow = rows[lastRowIndex];
      final avgPower = lastRow[avgPowerIndex];

      final newFrequency = (avgPower is num)
          ? avgPower.toDouble()
          : double.tryParse(avgPower.toString());

      final Map<String, double> newCountryFreqs = {};
      for (final station in _countryNames.keys) {
        final stationIndex = headerRow.indexOf(station);
        if (stationIndex != -1 && stationIndex < lastRow.length) {
          final value = lastRow[stationIndex];
          final freq = (value is num)
              ? value.toDouble()
              : double.tryParse(value.toString());
          if (freq != null && freq > 0) {
            newCountryFreqs[station] = freq;
          }
        }
      }

      if (newCountryFreqs.isNotEmpty) {
        final sum = newCountryFreqs.values.reduce((a, b) => a + b);
        final calculatedAvg = sum / newCountryFreqs.length;
        setState(() {
          _averageFrequency = calculatedAvg;
          _countryFrequencies = newCountryFreqs;
        });
      } else if (newFrequency != null) {
        setState(() {
          _averageFrequency = newFrequency;
          _countryFrequencies = newCountryFreqs;
        });
      }
    } catch (e) {
      debugPrint('Error loading frequency data: $e');
    }
  }
